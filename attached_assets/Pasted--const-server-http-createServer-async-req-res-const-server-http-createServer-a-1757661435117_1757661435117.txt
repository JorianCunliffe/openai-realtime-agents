@@
-  const server = http.createServer(async (req, res) => {
+  const server = http.createServer(async (req, res) => {
     if (!req.url) return;
     // simple health check (handy for TLS tests)
     if (req.url === "/healthz") {
       res.writeHead(200).end("ok");
       return;
     }
     return handle(req, res, parseUrl(req.url, true));
   });
@@
-  server.on("upgrade", (req, socket, head) => {
-    const url = parseUrl(req.url ?? "", true);
+  server.on("upgrade", (req, socket, head) => {
+    console.log("[UPGRADE]", (req.url ?? "").split("?")[0], "proto:", req.headers["sec-websocket-protocol"]);
+    const url = parseUrl(req.url ?? "", true);
     if (url.pathname !== "/twilio-media") {
       socket.write("HTTP/1.1 404 Not Found\r\n\r\n");
       socket.destroy();
       return;
     }
@@
 wss.on("connection", (ws: WebSocket, request: http.IncomingMessage, userCtx: UserCtx) => {
   console.log(`[WS] Connected: userId=${userCtx.userId}`);
-  let session: Awaited<ReturnType<typeof createRealtimeSession>> | null = null;
-  let streamSid: string | null = null;
+  let session: Awaited<ReturnType<typeof createRealtimeSession>> | null = null;
+  let streamSid: string | null = null;
 
   ws.on("message", async (data) => {
     let msg: AnyTwilioFrame;
     try {
       msg = JSON.parse(data.toString());
     } catch {
       console.warn("[WS] non-JSON frame");
       return;
     }
 
     switch (msg.event) {
       case "start": {
         const s = msg as StartFrame;
         userCtx.callSid = s.start.callSid;
         userCtx.streamSid = s.streamSid;
         console.log(`[Twilio][start] callSid=${s.start.callSid} streamSid=${s.streamSid}`);
-        session = await createRealtimeSession(userCtx);
+        session = await createRealtimeSession(userCtx);
+        // Pipe model â†’ Twilio
+        session.socket.on("message", (raw) => {
+          try {
+            const evt = JSON.parse(raw.toString());
+            if (evt.type === "response.output_audio.delta" && evt.delta && streamSid) {
+              ws.send(JSON.stringify({ event: "media", streamSid, media: { payload: evt.delta } }));
+            }
+          } catch (e) {
+            console.error("[Realtime] parse message err", e);
+          }
+        });
+        streamSid = s.streamSid;
         break;
       }
 
       case "media": {
-        const m = msg as MediaFrame;
-        // Forward base64 payload to model (stubbed)
-        session?.sendAudio(m.media.payload);
-
-        // ðŸ”Š Loopback to Twilio so the caller hears themselves (proof of life)
-        if (streamSid) {
-          const echo = {
-            event: "media",
-            streamSid,
-            media: { payload: m.media.payload }, // base64 PCMU back to Twilio
-          };
-          ws.send(JSON.stringify(echo));
-        }
+        const m = msg as MediaFrame;
+        // Twilio â†’ model
+        session?.sendAudio(m.media.payload);
         break;
       }
 
-      case "mark": {
-        const mk = msg as MarkFrame;
-        console.log(`[Twilio][mark] ${mk.mark.name}`);
-        break;
-      }
+      case "mark":
+        // optional: handle marks
+        break;
 
       case "stop": {
         const st = msg as StopFrame;
         console.log(`[Twilio][stop] streamSid=${st.streamSid}`);
         await session?.close();
         session = null;
         ws.close(1000, "done");
         break;
       }
 
+      case "connected":
+      case "dtmf":
+        // ignore
+        break;
+
       default:
-        console.log("[Twilio] Unknown event", (msg as any).event);
+        console.log("[Twilio] unknown event", (msg as any).event);
     }
   });
@@
   server.listen(port, () => {
     console.log(`[NEXT+WS] Listening on :${port} (WS path: /twilio-media)`);
   });